#include <lccv.hpp>
#include <libcamera_app.hpp>
#include <opencv2/opencv.hpp>

#include <QApplication>
#include <QPushButton>
#include <QWidget>
#include <QVBoxLayout>
#include <QHBoxLayout>
#include <QSlider>
#include <QLabel>
#include <QTimer>
#include <QImage>
#include <QPixmap>
#include <QLineEdit>
#include <QDoubleValidator>
#include <QFileDialog>
#include <QMessageBox>

#include <iostream>
#include "MarlinController.h"

bool negative = false; // Flag to indicate if the image is negative
int sprocketSlider = 20;
int sprocketThreshold = 220; // Threshold for sprocket hole detection (200 + this max 255)

//Bombsights for where we sample base film color. Adjust gate edges and KODAK text
//NOTE: Scale these during the 4k scan along with gaussian blur
int sampleXoffset = 25; // Offset for sampling the film color (center to left of sprocket center)
int sampleYoffset = 180; // Offset +- center of sprocket, in pixels


enum states {
    setup,              //When not in the scan loop
    scanning,
    frameRewind,
    frameAdvance,
};

states currentState = setup; // Initialize the current state

cv::Mat image, gray, binary;
bool holeFound = false;
int centerX;
int centerY;
lccv::PiCamera cam; // Global camera object
QLabel *videoLabel = nullptr; // Global reference to the video label
QPushButton *toggleWhiteBalanceButton = nullptr; // Global QLabel for white balance mode
QTimer *timer = nullptr; // Global pointer to the QTimer
QString saveFolder = "export"; // Default save folder

MarlinController *marlin = nullptr;

// Configurable
bool filmDirection = true;              // True for forward, false for backward (only disable/enable motors when it flips)
float film_thickness_mm = 0.15f;        // Film thickness per wrap
float super8frameHeight = 4.234f;
float base_spool_diameter = 31.3f;  //Diameter "pully" Marlin is configed to
float movement_mm_turn_target = base_spool_diameter * M_PI; // mm per rotation of the spool
float spool_diameter_mm = 31.3f;         // Set this to your empty take-up spool diameter
float movement_mm_turn;
float mmPerFrame;
float frameDelta = 0.0f;    //How close the sprocket got to center 360
float focusScore = 0.0f; // Focus score for the image
WhiteBalance_Modes currentWhiteBalanceMode = WB_INCANDESCENT; // Default to auto

int sprocketYsize = 140;
int sprocketXsize = sprocketYsize * .8f; // Width of the sprocket hole in pixels
int sprocketTolerance = 30; // Tolerance for sprocket hole detection in pixels 720p scan mode
int sprocketLeftMeat = 200; // Left edge of the sprocket hole in pixels 720p scan mode
int sprocketRightEdgeX = 300; // Right edge of the sprocket hole in pixels 720p scan mode

int lastCenterY = 0;
int stopCount = 0;

QString defaultFilename = "frame"; // Default filename for exports
int frameNumber = 0;
bool stopScanFlag = false;

// Display the movement data here:
int y_offset = 30; // Initial Y position for text
int line_spacing = 30; // Spacing between lines

QImage matToQImage(const cv::Mat &mat) {// Function to convert cv::Mat to QImage
    if (mat.empty()) {
        return QImage();
    }
    cv::Mat rgb;
    cv::cvtColor(mat, rgb, cv::COLOR_BGR2RGB); // Convert BGR to RGB
    return QImage(rgb.data, rgb.cols, rgb.rows, rgb.step, QImage::Format_RGB888).copy();
}

void onSprocketSliderChanged(int value) {// Function to handle sprocket threshold slider changes
    sprocketThreshold = value + 200;
    //std::cout << "Sprocket Threshold: " << sprocketThreshold << std::endl;
}

void onSprocketLeftMeatSliderChanged(int value) {// Function to handle sprocket left meat slider changes
    sprocketLeftMeat = value + 200;
    //std::cout << "Sprocket Left Meat: " << sprocketLeftMeat << std::endl;
}

void onSprocketRightEdgeSliderChanged(int value) {// Function to handle sprocket right edge slider changes
    sprocketRightEdgeX = value + 200;
    //std::cout << "Sprocket Right Edge: " << sprocketRightEdgeX << std::endl;
}

void onXOffsetSliderChanged(int value) {// Function to handle X offset slider changes
    sampleXoffset = value;
    //std::cout << "Film Color Sample X Offset: " << sampleXoffset << std::endl;
}

void onYOffsetSliderChanged(int value) {// Function to handle Y offset slider changes
    sampleYoffset = value;
    //std::cout << "Film Color Sample Y Offset: " << sampleYoffset << std::endl;
}

void onSprocketSizeSliderChanged(int value) {// Function to handle sprocket size slider changes
    sprocketYsize = value + 100;
    sprocketXsize = sprocketYsize * .8f; // Update the width based on the height
}

void compute_move_per_frame() {

    float framesPerTurn = (spool_diameter_mm * M_PI) / super8frameHeight; // Frames per rotation of the spool
    
    movement_mm_turn = 0.0f;
    movement_mm_turn_target = base_spool_diameter * M_PI; // mm per rotation of the spool

    mmPerFrame = movement_mm_turn_target / framesPerTurn; // mm per frame of film

}

void reset_spool_tracker(QLineEdit *spoolDiameterInput) {
    // Read the value from the text entry field
    QString inputText = spoolDiameterInput->text();
    if (!inputText.isEmpty()) {
        float newDiameter = inputText.toFloat();

        if (newDiameter > 0.0f) {
            spool_diameter_mm = newDiameter; // Update the spool diameter
            std::cout << "Spool diameter updated to: " << spool_diameter_mm << " mm" << std::endl;
        } else {
            std::cerr << "Invalid spool diameter entered. Using default value: " << spool_diameter_mm << " mm" << std::endl;
        }
    } else {
        std::cerr << "No spool diameter entered. Using default value: " << spool_diameter_mm << " mm" << std::endl;
    }

    frameNumber = 0;

    compute_move_per_frame();

    // Reset the total movement tracker
    //data.total_y_movement_mm = 0.0f;
    std::cout << "Spool tracker reset. Total movement set to 0.0 mm." << std::endl;
}

void advanceFilmTracking(float frames, float speed, bool waitForResponse = false) {

    float mm = frames * mmPerFrame; // Convert frames to mm using the mm per frame value
    marlin->advanceFilm(mm, speed, waitForResponse); // Advance the film by mm
    movement_mm_turn += mm;     // Update the total movement tracker

    //Add multiple-turn stacking
    if (movement_mm_turn >= movement_mm_turn_target) {
        float leftover = movement_mm_turn - movement_mm_turn_target;  //Save this

        spool_diameter_mm += (film_thickness_mm * 2);   // Increase the spool diameter by twice the film thickness

        compute_move_per_frame();       // Recompute the movement per frame based on diameter
        movement_mm_turn = leftover;    // Reset the movement to the leftover value
    }

}

void rewindFilmTracking(float frames, float speed, bool waitForResponse = false) {

}

void applyWhiteBalance() {
    cam.options->setWhiteBalance(currentWhiteBalanceMode); // Apply the selected mode
    std::cout << "Applied White Balance Mode: " << currentWhiteBalanceMode << std::endl;
}

void toggleWhiteBalanceMode() {

    if (currentState != setup) {
        return;
    }

    // Cycle through the white balance modes
    switch (currentWhiteBalanceMode) {
        case WB_INCANDESCENT:
            currentWhiteBalanceMode = WB_TUNGSTEN;
            break;
        case WB_TUNGSTEN:
            currentWhiteBalanceMode = WB_FLUORESCENT;
            break;
        case WB_FLUORESCENT:
            currentWhiteBalanceMode = WB_INDOOR;
            break;
        case WB_INDOOR:
            currentWhiteBalanceMode = WB_DAYLIGHT;
            break;
        case WB_DAYLIGHT:
            currentWhiteBalanceMode = WB_CLOUDY;
            break;
        case WB_CLOUDY:
            currentWhiteBalanceMode = WB_AUTO;
            break;
    }

    // Update the QLabel with the current white balance mode
    if (toggleWhiteBalanceButton) {
        QString wbText;
        switch (currentWhiteBalanceMode) {
            case WB_INCANDESCENT: wbText = "Incandescent"; break;
            case WB_TUNGSTEN: wbText = "Tungsten"; break;
            case WB_FLUORESCENT: wbText = "Fluorescent"; break;
            case WB_INDOOR: wbText = "Indoor"; break;
            case WB_DAYLIGHT: wbText = "Daylight"; break;
            case WB_CLOUDY: wbText = "Cloudy"; break;
        }
        toggleWhiteBalanceButton->setText("White Balance: " + wbText);
    }

    // Apply the new white balance mode
    cam.stopVideo(); // Stop the video stream
    applyWhiteBalance(); // Apply the current white balance mode
    cam.startVideo(); // Restart the video stream

    // Log the current mode
    std::cout << "White Balance Mode Toggled: " << currentWhiteBalanceMode << std::endl;
}

void capturePhoto() {
    std::cout << "Switching to still mode to capture photo..." << std::endl;

    // Stop the video stream
    cam.stopVideo();
    cam.startPhoto(); // Start the still mode
    //applyWhiteBalance(); // Apply the current white balance mode

    // Capture a single frame
    cv::Mat photo;
    if (!cam.capturePhoto(photo)) {
        std::cerr << "Error: Failed to capture photo!" << std::endl;
        return;
    }

    cam.stopPhoto(); // Stop the still mode

    float centerX4k; // Scale to 4k width
    float centerY4k; // Scale to 4k height

    // Convert the image to grayscale
    cv::cvtColor(photo, gray, cv::COLOR_BGR2GRAY);

    // Apply binary thresholding to isolate the black sprocket hole
    cv::threshold(gray, binary, sprocketThreshold, 255, cv::THRESH_BINARY);

    // Find contours in the binary image
    std::vector<std::vector<cv::Point>> contours;
    cv::findContours(binary, contours, cv::RETR_EXTERNAL, cv::CHAIN_APPROX_SIMPLE);

    // Iterate through contours to find the sprocket hole on the left side
    holeFound = false;

    for (const auto& contour : contours) {
        cv::Rect boundingBox = cv::boundingRect(contour);

        // Check if the bounding box is on the left side of the frame
        if (boundingBox.x < photo.cols / 4 && boundingBox.width > 330 && boundingBox.height > 420) {

            holeFound = true;

            //Calc center of boundingBox:
            centerX4k = boundingBox.x + (boundingBox.width / 2);
            centerY4k = boundingBox.y + (boundingBox.height / 2);

            break; // Stop after detecting the first sprocket hole
        }
    }

    if (negative) {

        cv::bitwise_not(photo, photo);        //Invert image
        cv::Mat blurImage = photo.clone();      //Copy
        cv::GaussianBlur(blurImage, blurImage, cv::Size(5, 5), 0);  //Blur copy

        cv::Vec3b pixelValue;
        centerX4k -= (sampleXoffset * 3.16875); // Scale to 4k width
        float sampleYoffset4k = sampleYoffset * 4.22222; // Scale to 4k height

        //Get base film color from either above or below the sprocket hole depending on vertical position
        if (centerY4k < 1520) { //Top half? Detect below hole
            pixelValue = blurImage.at<cv::Vec3b>(centerY4k + sampleYoffset4k, centerX4k);
        }
        else { //Bottom half? Detect above hole
            pixelValue = blurImage.at<cv::Vec3b>(centerY4k - sampleYoffset4k, centerX4k); 
        }

        //Get the RGB values of the area just left of the sprocket hole
        int redValue = pixelValue[2]; // Red channel value
        int greenValue = pixelValue[1]; // Green channel value
        int blueValue = pixelValue[0]; // Blue channel value

        //Remove those colors from image:
        cv::subtract(photo, cv::Scalar(blueValue, greenValue, redValue), photo); // Subtract the pixel value from the image

    }  

    // Center photo vertically to centerY4k, then crop height to 2000 pixels:
    int cropHeight = 1900; // Height of the cropped image
    int cropY = static_cast<int>(centerY4k - (cropHeight / 2)); // Center the photo vertically
    int cropWidth = 3280; // Width of the cropped image

    // Ensure the cropping region is within the bounds of the image
    if (cropY < 0) {
        cropY = 0; // Adjust if the top of the crop region is above the image
    }
    if (cropY + cropHeight > photo.rows) {
        cropY = photo.rows - cropHeight; // Adjust if the bottom of the crop region is below the image
    }

    // Create the cropping rectangle
    cv::Rect cropRegion((4056 - cropWidth) / 2, cropY, cropWidth, cropHeight);

    // Ensure the crop height does not exceed the image height
    if (cropHeight > photo.rows) {
        cropRegion.height = photo.rows;
    }

    // Crop the photo without making a copy:
    cv::Mat croppedPhoto = photo(cropRegion); // Crop the photo using the defined region

    centerY4k = cropHeight / 2; //New center pixel vert
    centerX4k +=  ((4056 - cropWidth) / 2); //New center pixel horz offset after crop left right

    cv:flip(croppedPhoto, croppedPhoto, 0);      // Flip the image vertically

    cam.startVideo(); // Restart the video stream

    // Save the photo to a file with the frame number
    std::ostringstream oss;
    oss << std::setw(5) << std::setfill('0') << frameNumber; // Format the frame number with leading zeros
    std::string formattedFrameNumber = oss.str();
    std::string filename = saveFolder.toStdString() + "/" + defaultFilename.toStdString() + "_" + formattedFrameNumber + ".png";
    cv::imwrite(filename, croppedPhoto); // Save the photo to the selected folder

    // Increment the frame number
    frameNumber++;

}

float computeFocusScore(const cv::Mat &image) {
    // Extract a strip of pixels from the center of the image
    int stripHeight = 100; // Height of the strip
    int centerY = image.rows / 2;
    cv::Rect centerStrip(0, centerY - stripHeight / 2, image.cols, stripHeight);
    cv::Mat strip = image(centerStrip);

    // Convert the strip to grayscale if it's not already
    cv::Mat grayStrip;
    if (strip.channels() == 3) {
        cv::cvtColor(strip, grayStrip, cv::COLOR_BGR2GRAY);
    } else {
        grayStrip = strip;
    }

    // Apply the Laplacian operator to detect edges
    cv::Mat laplacian;
    cv::Laplacian(grayStrip, laplacian, CV_64F);

    // Compute the variance of the Laplacian
    cv::Scalar mean, stddev;
    cv::meanStdDev(laplacian, mean, stddev);
    double variance = stddev[0] * stddev[0];

    // Return the focus score (lower is better focus)
    return static_cast<float>(variance);
}

void showPopup(const QString &message) {
    QMessageBox popup;
    popup.setWindowTitle("Information");
    popup.setText(message);
    popup.setIcon(QMessageBox::Information);
    popup.setStandardButtons(QMessageBox::Ok);
    popup.exec(); // Show the popup
}

// Button functions
void onWhiteBalanceClicked() {


}

void checkForwardDirection() {      //Forward movement, change direction if needed

    if (filmDirection != true) {
        marlin->disableSingleMotor("X"); // Disable the X motor feed
        marlin->enableSingleMotor("Y"); // Enable the Y motor takeup
        filmDirection = true; // Set the direction to forward
    }

}

void checkBackwardDirection() {     //Backward movement, change direction if needed

    if (filmDirection != false) {
        marlin->disableSingleMotor("Y"); // Disable the Y motor takeup
        marlin->enableSingleMotor("X"); // Enable the X motor feed
        filmDirection = false; // Set the direction to backward
    }

}

void singleFrameAdvanceForScan() {
    advanceFilmTracking(1.0f + frameDelta, 1000.0f);
    stopCount = 0;
    lastCenterY = -100;
    currentState = scanning;

}

void shuttleFilmForward(float frames, float speed) {
    checkForwardDirection(); // Check and set the direction to forward
    advanceFilmTracking(frames, speed, false); // Call the overloaded function with waitForResponse = true

}

void onStartScanButtonClicked() {

    //Make a popup window if currentState is not setup:
    if (currentState != setup) {
        showPopup("Scan already in progress");
        return; // Exit if the scan is already in progress
    }

    if (centerY < 340 || centerY > 380) { // Check if the sprocket is centered
        showPopup("Center sprocket hole in the frame before scanning");
        return; // Exit if the sprocket is not centered
    }

    checkForwardDirection();
    currentState = scanning; // Set the current state to scanning
    capturePhoto(); // Capture a photo when the scan starts
    singleFrameAdvanceForScan(); // Advance the film by one frame

}

void onStopScanButtonClicked() {

    if (currentState == scanning) {
        stopScanFlag = true;
    }

}

void onExitButtonClicked(QApplication &app) {
    std::cout << "Exit button clicked!" << std::endl;

    // Stop the QTimer
    timer->stop();
    std::cout << "QTimer stopped." << std::endl;

    // Clean up Marlin controller
    if (marlin) {
        delete marlin;
        marlin = nullptr;
        std::cout << "Marlin controller disconnected." << std::endl;
    }

    // Stop the camera
    cam.stopVideo();
    std::cout << "Camera stopped." << std::endl;

    // Quit the application
    app.quit();
}

void onLightOnButtonClicked() {
    marlin->sendGCode("M42 P205 S255"); // Turn on the light (replace with your pin number)
}

void onLightOffButtonClicked() {
    marlin->sendGCode("M42 P205 S0"); // Turn off the light (replace with your pin number)
}

void onFanOnButtonClicked() {
    marlin->sendGCode("M106 S255"); // Turn on the fan (replace with your pin number)
}

void onFanOffButtonClicked() {
    marlin->sendGCode("M107"); // Turn off the fan (replace with your pin number)
}

void onEnableMotorsClicked() {
    marlin->enableMotors(); // Enable all motors
}

void onDisableMotorsClicked() {
    marlin->disableMotors(); // Disable all motors
}


void cameraSetup() {
    uint32_t num_cams = LibcameraApp::GetNumberCameras();
    std::cout << "Found " << num_cams << " cameras." << std::endl;

    cam.options->video_width = 1280;
    cam.options->video_height = 720;
    cam.options->framerate = 60;
    cam.options->photo_width = 4056;
    cam.options->photo_height = 3040;
    cam.options->denoise = "off";

    if (!cam.startVideo()) {
        std::cerr << "Error: Failed to start video!" << std::endl;
        exit(-1); // Exit if the camera fails to start
    }

}

void infoLine(const std::string &text, float textSize = 0.6f) {

    cv::putText(image, text, cv::Point(10, y_offset), cv::FONT_HERSHEY_SIMPLEX, textSize, cv::Scalar(255, 255, 255), 1);
    y_offset += line_spacing;

}

// Function to update the video feed
void updateVideoFeed() {

    if (!cam.getVideoFrame(image, 1000)) { // Capture a video frame from the camera
        std::cerr << "Error: Failed to capture video frame!" << std::endl;
        return;
    }

    cv::cvtColor(image, gray, cv::COLOR_BGR2GRAY);    // Convert the image to grayscale

    if (currentState == setup) {                //Don't do during scanning (focus should be set)
        focusScore = computeFocusScore(image);
    }

    // Apply binary thresholding to isolate the black sprocket hole
    cv::threshold(gray, binary, sprocketThreshold, 255, cv::THRESH_BINARY);

    //Draw a vertical yellow line on image at sprocketLeftMeat:
    cv::line(image, cv::Point(sprocketLeftMeat, 0), cv::Point(sprocketLeftMeat, image.rows), cv::Scalar(0, 255, 255), 2); // Draw the line in yellow

    //Draw a verticle red line on image at sprocketRightEdgeX:
    cv::line(image, cv::Point(sprocketRightEdgeX, 0), cv::Point(sprocketRightEdgeX, image.rows), cv::Scalar(0, 0, 255), 2); // Draw the line in red

    //Crop the binary image to be no wider than sprockerRightEdgeX:
    cv::Rect cropRegion(0, 0, sprocketRightEdgeX, image.rows); // Define the cropping region
    cv::Mat croppedBinary = binary(cropRegion); // Crop the binary image using the defined region

    // Find contours in the binary image
    std::vector<std::vector<cv::Point>> contours;
    cv::findContours(croppedBinary, contours, cv::RETR_EXTERNAL, cv::CHAIN_APPROX_SIMPLE);

    // Iterate through contours to find the sprocket hole on the left side
    holeFound = false;
    cv::Rect sprocketBoundingBox;

    for (const auto& contour : contours) {

        //Draw a blue outline around this contour:
        //cv::drawContours(image, contours, -1, cv::Scalar(255, 0, 0), 2); // Draw the contour in blue

        cv::Rect boundingBox = cv::boundingRect(contour);

        if (boundingBox.x < (image.cols / 3)) {       //Must be on left third

            //Box must be at least 70 pixels wide and 80 pixels tall, but not exceed 200 pixels wide and 300 pixels tall
            if (boundingBox.width > sprocketXsize && boundingBox.height > sprocketYsize && boundingBox.width < (sprocketXsize + sprocketTolerance) && boundingBox.height < (sprocketYsize + sprocketTolerance)) {
                // Draw a green rectangle around the detected sprocket hole
                cv::rectangle(image, boundingBox, cv::Scalar(0, 255, 0), 2);
                sprocketBoundingBox = boundingBox;
                holeFound = true;

                //Calc center of boundingBox:
                centerX = boundingBox.x + (boundingBox.width / 2);
                centerY = boundingBox.y + (boundingBox.height / 2);

                //Draw a blue rectangle centered on the sprocket hole, at size sprocketXsize x sprocketYsize:
                cv::rectangle(image, cv::Point(centerX - (sprocketXsize / 2), centerY - (sprocketYsize / 2)), cv::Point(centerX + (sprocketXsize / 2), centerY + (sprocketYsize / 2)), cv::Scalar(255, 0, 0), 2);

                //Stay between sloppy gate image and the occasional "KODAK" text
                centerX -= sampleXoffset; // Offset the centerX by the sampleXoffset value

                break; // Stop after detecting the first sprocket hole
            }

        }


        // Check if the bounding box is on the left side of the frame
        // if (boundingBox.x < image.cols / 4 && boundingBox.width > 70 && boundingBox.height > 80) {
        //     // Draw a rectangle around the detected sprocket hole
        //     cv::rectangle(image, boundingBox, cv::Scalar(0, 255, 0), 2);
        //     sprocketBoundingBox = boundingBox;
        //     holeFound = true;

        //     //Calc center of boundingBox:
        //     centerX = boundingBox.x + (boundingBox.width / 2);
        //     centerY = boundingBox.y + (boundingBox.height / 2);

        //     //Stay between sloppy gate image and the occasional "KODAK" text
        //     centerX -= sampleXoffset; // Offset the centerX by the sampleXoffset value

        //     break; // Stop after detecting the first sprocket hole
        // }
    }

    bool takePhoto = false;

    if (holeFound) {

        if (negative) {

            cv::bitwise_not(image, image);        //Invert image
            cv::Mat blurImage = image.clone();      //Copy
            cv::GaussianBlur(blurImage, blurImage, cv::Size(5, 5), 0);  //Blur copy
    
            cv::Vec3b pixelValue;
    
            //Get base film color from either above or below the sprocket hole depending on vertical position
            if (centerY < 360) { //Top half? Detect below hole
                pixelValue = blurImage.at<cv::Vec3b>(centerY + sampleYoffset, centerX);
                cv::circle(image, cv::Point(centerX, centerY - sampleYoffset), 20, cv::Scalar(0, 0, 128), -1);
                cv::circle(image, cv::Point(centerX, centerY + sampleYoffset), 20, cv::Scalar(0, 0, 255), -1);
            }
            else { //Bottom half? Detect above hole
                pixelValue = blurImage.at<cv::Vec3b>(centerY - sampleYoffset, centerX); 
                cv::circle(image, cv::Point(centerX, centerY - sampleYoffset), 20, cv::Scalar(0, 0, 255), -1);
                cv::circle(image, cv::Point(centerX, centerY + sampleYoffset), 20, cv::Scalar(0, 0, 128), -1);
            }
    
            //Get the RGB values of the area just left of the sprocket hole
            //cv::Vec3b pixelValue = processedImage.at<cv::Vec3b>(sprocketBoundingBox.y - 20, sprocketBoundingBox.x);
            int redValue = pixelValue[2]; // Red channel value
            int greenValue = pixelValue[1]; // Green channel value
            int blueValue = pixelValue[0]; // Blue channel value
    
            //Remove those colors from video image:
            cv::subtract(image, cv::Scalar(blueValue, greenValue, redValue), image); // Subtract the pixel value from the image
    
        }

        if (currentState == scanning) {
            // Check if the centerY has changed significantly since last frame:
            if (abs(centerY - lastCenterY) < 5) {
                stopCount++;
            }
            else {
                stopCount = 0; // Reset the stop count if the centerY changes significantly             
            }

            if (stopCount == 5) {   //Settled 5 frames in a row?
                takePhoto = true;   // Set the flag to take a photo
            }
            else {
                lastCenterY = centerY; // Update lastCenterY to the current centerY
            }

        }

        // Calculate the deltaY offset from 360 vertical center as a percentage:
        frameDelta = (360 - centerY) / 720.0f; // Normalize to a value between -1 and 1

    }
    else {
        if (currentState == setup) {
           //Draw a blue rectangle on the left edge of the image, centered vertically, the size of sprocketXsize x sprocketYsize:
           cv::rectangle(image, cv::Point(0, (image.rows / 2) - (sprocketYsize / 2)), cv::Point(sprocketXsize, (image.rows / 2) + (sprocketYsize / 2)), cv::Scalar(255, 0, 0), 2);
           //Put a giant X in middle of this rectangle:
           cv::putText(image, "X", cv::Point(sprocketXsize / 2, (image.rows / 2) + (sprocketYsize / 2)), cv::FONT_HERSHEY_SIMPLEX, 10.0, cv::Scalar(255, 0, 0), 10);
                
        }

    }

    cv::flip(image, image, 0);      // Flip the image vertically

    y_offset = 30; // Initial Y position for text
    line_spacing = 30; // Spacing between lines

    switch(currentState) {
        case setup:
            infoLine("STATE: SETUP", 1.0f); 
            break;

        case scanning:
            infoLine("STATE: SCANNING", 1.0f);
            break;

        case frameAdvance:
            infoLine("STATE: FRAME ADVANCING", 1.0f);
            break;

        case frameRewind:
            infoLine("STATE: FRAME REWINDING", 1.0f);
            break;
    }

    infoLine("Sprocket XY @ 720p: " + std::to_string(centerX) + " " + std::to_string(centerY));
    infoLine("Sprocket last error delta: " + std::to_string(frameDelta) + "%");
    infoLine("Feed spool diameter: " + std::to_string(spool_diameter_mm) + " mm");      //TODO: ADD DATA
    infoLine("Feed movement per frame: " + std::to_string(mmPerFrame) + " mm");      //TODO: ADD DATA
    infoLine("Takeup spool diameter: " + std::to_string(spool_diameter_mm) + " mm");
    infoLine("Takeup movement per frame: " + std::to_string(mmPerFrame) + " mm");      //TODO: ADD DATA
    infoLine("Movement per Turn: " + std::to_string(movement_mm_turn) + " mm");      //TODO: ADD DATA
    infoLine("Movement Target: " + std::to_string(movement_mm_turn_target) + " mm");      //TODO: ADD DATA


    cv::putText(image, "Focus Score: " + std::to_string(focusScore) + " higher is better", 
                cv::Point(10, 690), cv::FONT_HERSHEY_SIMPLEX, 1.0, cv::Scalar(255, 255, 255), 1);


    QImage qImage = matToQImage(image); // Convert cv::Mat to QImage

    if (!qImage.isNull() && videoLabel != nullptr) {
        videoLabel->setPixmap(QPixmap::fromImage(qImage)); // Display the frame in QLabel
    }

    if (takePhoto) {
        capturePhoto(); // Capture a photo if the condition is met
        takePhoto = false; // Reset the flag after capturing the photo

        if (stopScanFlag) {
            stopScanFlag = false; // Reset the flag after stopping the scan
            currentState = setup; // Switch back to setup state
        }
        else {
            singleFrameAdvanceForScan(); // Advance the film by one frame
        }

    }

}

void state_machine() {

    switch (currentState) {
        case setup:

            break;
    }

    updateVideoFeed(); // Call update video feed in setup state

}

int main(int argc, char *argv[]) {
    QApplication app(argc, argv);

    try {
        marlin = new MarlinController("/dev/ttyACM0", 115200); // Replace with your serial port and baud rate
    } catch (const std::exception &e) {
        std::cerr << "Error initializing Marlin controller: " << e.what() << std::endl;
        return -1;
    }

    //Default is an empty take-up spool of 31.3mm diameter but you can change this after boot
    spool_diameter_mm = base_spool_diameter; // Set the spool diameter to the base diameter
    compute_move_per_frame(); //Calc default takeup spool (empty default)

    cameraSetup();

    // Create the main window
    QWidget window;
    window.setWindowTitle("Super 8mm Super Scanner");
    window.resize(1800, 900); // Set the window size to 1800x900
    window.setStyleSheet("background-color: #333333;"); // Dark gray background

    // Create a video display label
    videoLabel = new QLabel(); // Assign to the global variable
    videoLabel->setFixedSize(1280, 720); // Set video display size
    videoLabel->setStyleSheet("background-color: black;"); // Black background for video

    // Create sliders
    QSlider *sprocketSliderWidget = new QSlider(Qt::Horizontal);
    sprocketSliderWidget->setRange(0, 55);  //It's 200 to 255 but we scale it on callback
    sprocketSliderWidget->setValue(sprocketSlider);
    QObject::connect(sprocketSliderWidget, &QSlider::valueChanged, onSprocketSliderChanged);
    
    QSlider *sprocketLeftEdgeSliderWidget = new QSlider(Qt::Horizontal);
    sprocketLeftEdgeSliderWidget->setRange(0, 150); // Range for left edge slider
    sprocketLeftEdgeSliderWidget->setValue(sprocketLeftMeat - 200); // Set initial value
    QObject::connect(sprocketLeftEdgeSliderWidget, &QSlider::valueChanged, onSprocketLeftMeatSliderChanged);

    QSlider *sprocketRightEdgeSliderWidget = new QSlider(Qt::Horizontal);
    sprocketRightEdgeSliderWidget->setRange(0, 150); // Range for right edge slider
    sprocketRightEdgeSliderWidget->setValue(sprocketRightEdgeX - 200); // Set initial value
    QObject::connect(sprocketRightEdgeSliderWidget, &QSlider::valueChanged, onSprocketRightEdgeSliderChanged);

    QSlider *xOffsetSliderWidget = new QSlider(Qt::Horizontal);
    xOffsetSliderWidget->setRange(0, 50);
    xOffsetSliderWidget->setValue(sampleXoffset);
    QObject::connect(xOffsetSliderWidget, &QSlider::valueChanged, onXOffsetSliderChanged);

    QSlider *yOffsetSliderWidget = new QSlider(Qt::Horizontal);
    yOffsetSliderWidget->setRange(140, 240);
    yOffsetSliderWidget->setValue(sampleYoffset);
    QObject::connect(yOffsetSliderWidget, &QSlider::valueChanged, onYOffsetSliderChanged);

    QSlider *sprocketSizeSliderWidget = new QSlider(Qt::Horizontal);
    sprocketSizeSliderWidget->setRange(0, 100); // Range for sprocket size slider
    sprocketSizeSliderWidget->setValue(sprocketYsize - 100); // Set initial value
    QObject::connect(sprocketSizeSliderWidget, &QSlider::valueChanged, onSprocketSizeSliderChanged);

    // Create labels for sliders
    QLabel *sprocketSliderLabel = new QLabel("Sprocket White Threshold Low to High");
    sprocketSliderLabel->setStyleSheet("color: white;"); // White text for better visibility

    QLabel *sprocketLeftEdgeSliderLabel = new QLabel("Sprocket Left Meat");
    sprocketLeftEdgeSliderLabel->setStyleSheet("color: white;"); // White text for better visibility

    QLabel *sprocketRightEdgeSliderLabel = new QLabel("Sprocket Rightmost Edge");
    sprocketRightEdgeSliderLabel->setStyleSheet("color: white;"); // White text for better visibility

    QLabel *sprocketSizeSliderLabel = new QLabel("Sprocket Minimum Size"    );
    sprocketSizeSliderLabel->setStyleSheet("color: white;"); // White text for better visibility

    QLabel *offsetSliderLabel = new QLabel("Negative Film Color XY Sample Points");
    offsetSliderLabel->setStyleSheet("color: white;");

    // Create a text entry field for spool diameter
    QLineEdit *spoolDiameterInput = new QLineEdit();
    spoolDiameterInput->setPlaceholderText("Starting spool diameter (mm) default 31.3");
    spoolDiameterInput->setStyleSheet(
        "color: black;"                // Text color
        "background-color: white;"     // Background color
        "selection-color: white;"      // Selected text color
        "selection-background-color: blue;" // Background color for selected text
        "border: 1px solid gray;"      // Border styling
        "padding: 5px;"                // Padding for better spacing
        "font-size: 14px;"             // Font size for readability
        "caret-color: black;"          // Cursor (caret) color
    );
    spoolDiameterInput->setValidator(new QDoubleValidator(0.0, 1000.0, 2)); // Allow only valid float values (0.0 to 100.0)

    // Create buttons
    QPushButton *nudgeButtonForward = new QPushButton("Nudge Forward");
    QPushButton *nudgeButtonBack = new QPushButton("Nudge Backward");
    QPushButton *startScanButton = new QPushButton("Start Scan");
    QPushButton *stopScanButton = new QPushButton("Stop Scan");
    QPushButton *exitButton = new QPushButton("Exit");
    QPushButton *lightOnButton = new QPushButton("Light On");
    QPushButton *lightOffButton = new QPushButton("Light Off");
    QPushButton *fanOnButton = new QPushButton("Fan On");
    QPushButton *fanOffButton = new QPushButton("Fan Off");
    QPushButton *advance1Button = new QPushButton("Frame +1");
    QPushButton *advance10Button = new QPushButton("Frame +10");
    QPushButton *advance50Button = new QPushButton("Frame +50");
    QPushButton *advance100Button = new QPushButton("Frame +100");
    QPushButton *resetSpoolButton = new QPushButton("Reset Spool");
    QPushButton *enableMotorsButton = new QPushButton("Enable Motors");
    QPushButton *disableMotorsButton = new QPushButton("Disable Motors");

    QLineEdit *filenameInput = new QLineEdit();
    filenameInput->setPlaceholderText("Change base filename");
    //filenameInput->setText(defaultFilename); // Set the default value
    filenameInput->setStyleSheet(
        "color: black;"                // Text color
        "background-color: white;"     // Background color
        "selection-color: white;"      // Selected text color
        "selection-background-color: blue;" // Background color for selected text
        "border: 1px solid gray;"      // Border styling
        "padding: 5px;"                // Padding for better spacing
        "font-size: 14px;"             // Font size for readability
        "caret-color: black;"          // Cursor (caret) color
    );
    QObject::connect(filenameInput, &QLineEdit::textChanged, [](const QString &text) {
        defaultFilename = text; // Update the global variable when the text changes
    });

    QPushButton *selectFolderButton = new QPushButton("Select Save Folder");
    QObject::connect(selectFolderButton, &QPushButton::clicked, []() {
        QString folder = QFileDialog::getExistingDirectory(nullptr, "Select Save Folder", saveFolder);
        if (!folder.isEmpty()) {
            saveFolder = folder; // Update the save folder path
            std::cout << "Save folder updated to: " << saveFolder.toStdString() << std::endl;
        }
    });

    QPushButton *negativeButton = new QPushButton("Positive Film");
    QObject::connect(negativeButton, &QPushButton::clicked, [negativeButton]() {
        negative = !negative; // Toggle the negative boolean
        if (negative) {
            negativeButton->setText("Negative Film");
        } else {
            negativeButton->setText("Positive Film");
        }
        std::cout << "Negative mode is now " << (negative ? "ON" : "OFF") << std::endl;
    });

    toggleWhiteBalanceButton = new QPushButton("White Balance: Incandescent");
    QObject::connect(toggleWhiteBalanceButton, &QPushButton::clicked, []() {
        toggleWhiteBalanceMode();
    });

    // Connect film transport buttons to their respective functions
    QObject::connect(nudgeButtonForward, &QPushButton::clicked, []() {
        shuttleFilmForward(0.05f, 250.0f); // Move the film forward by one frame
    });

    QObject::connect(advance1Button, &QPushButton::clicked, []() {
        shuttleFilmForward(1.0f + frameDelta, 1000.0f); // Move the film forward by one frame
    });

    QObject::connect(advance10Button, &QPushButton::clicked, []() {
        shuttleFilmForward(10.0f, 1000.0f); // Move the film forward by one frame
    });

    QObject::connect(advance50Button, &QPushButton::clicked, []() {
        shuttleFilmForward(50.0f, 2000.0f); // Move the film forward by one frame
    });

    QObject::connect(advance100Button, &QPushButton::clicked, []() {
        shuttleFilmForward(100.0f, 3000.0f); // Move the film forward by one frame
    });

    QObject::connect(startScanButton, &QPushButton::clicked, onStartScanButtonClicked);
    QObject::connect(stopScanButton, &QPushButton::clicked, onStopScanButtonClicked);


    //Connect controls and setup

    QObject::connect(exitButton, &QPushButton::clicked, [&app]() { onExitButtonClicked(app); });
    QObject::connect(lightOnButton, &QPushButton::clicked, onLightOnButtonClicked);
    QObject::connect(lightOffButton, &QPushButton::clicked, onLightOffButtonClicked);
    QObject::connect(fanOnButton, &QPushButton::clicked, onFanOnButtonClicked);
    QObject::connect(fanOffButton, &QPushButton::clicked, onFanOffButtonClicked);



    QObject::connect(resetSpoolButton, &QPushButton::clicked, [spoolDiameterInput]() {
        reset_spool_tracker(spoolDiameterInput);
    });

    QObject::connect(enableMotorsButton, &QPushButton::clicked, onEnableMotorsClicked);
    QObject::connect(disableMotorsButton, &QPushButton::clicked, onDisableMotorsClicked);

    // Create a grid layout for the sliders
    QGridLayout *slidersGridLayout = new QGridLayout();

    //Align stuff to top:
    slidersGridLayout->setAlignment(Qt::AlignTop); // Align the grid layout to the top

    // Add the sprocket slider and label to the left column
    slidersGridLayout->addWidget(sprocketSliderLabel, 0, 0); // Row 0, Column 0
    slidersGridLayout->addWidget(sprocketSliderWidget, 1, 0); // Row 1, Column 0
    slidersGridLayout->addWidget(sprocketLeftEdgeSliderLabel, 2, 0); // Row 2, Column 0
    slidersGridLayout->addWidget(sprocketLeftEdgeSliderWidget, 3, 0); // Row 0, Column 0
    slidersGridLayout->addWidget(sprocketRightEdgeSliderLabel, 4, 0); // Row 1, Column 0
    slidersGridLayout->addWidget(sprocketRightEdgeSliderWidget, 5, 0); // Row 0, Column 0
    slidersGridLayout->addWidget(sprocketSizeSliderLabel, 6, 0); // Row 3, Column 0
    slidersGridLayout->addWidget(sprocketSizeSliderWidget, 7, 0); // Row 2, Column 0
    
    // Add the film sample sliders and labels to the right column
    slidersGridLayout->addWidget(offsetSliderLabel, 0, 1); // Row 0, Column 1
    slidersGridLayout->addWidget(xOffsetSliderWidget, 1, 1); // Row 1, Column 1
    slidersGridLayout->addWidget(yOffsetSliderWidget, 2, 1); // Row 3, Column 1

    // Create a layout for the video and sliders
    QVBoxLayout *videoAndSlidersLayout = new QVBoxLayout();
    videoAndSlidersLayout->addWidget(videoLabel, 0, Qt::AlignCenter); // Center the video label
    videoAndSlidersLayout->addLayout(slidersGridLayout);

    // Create a layout for the buttons
    QVBoxLayout *buttonsLayout = new QVBoxLayout();
    buttonsLayout->addWidget(nudgeButtonForward);
    buttonsLayout->addWidget(advance1Button);
    buttonsLayout->addWidget(advance10Button);
    buttonsLayout->addWidget(advance50Button);
    buttonsLayout->addWidget(advance100Button);
    buttonsLayout->addWidget(startScanButton);
    buttonsLayout->addWidget(stopScanButton);
    buttonsLayout->addWidget(filenameInput);
    buttonsLayout->addWidget(selectFolderButton);

    buttonsLayout->addStretch(); // Add stretch to push buttons to the top

    QVBoxLayout *buttonsSetup = new QVBoxLayout();
    buttonsSetup->addWidget(spoolDiameterInput);
    buttonsSetup->addWidget(resetSpoolButton);
    buttonsSetup->addWidget(toggleWhiteBalanceButton);
    buttonsSetup->addWidget(negativeButton);
    buttonsSetup->addWidget(lightOnButton);
    buttonsSetup->addWidget(lightOffButton);
    buttonsSetup->addWidget(fanOnButton);
    buttonsSetup->addWidget(fanOffButton);
    buttonsSetup->addWidget(enableMotorsButton);
    buttonsSetup->addWidget(disableMotorsButton);
    buttonsSetup->addWidget(exitButton);

    buttonsSetup->addStretch(); // Add stretch to push buttons to the top

    // Create a horizontal layout for the main content
    QHBoxLayout *mainLayout = new QHBoxLayout();
    mainLayout->addLayout(videoAndSlidersLayout);
    mainLayout->addLayout(buttonsLayout);
    mainLayout->addLayout(buttonsSetup);

    // Set the layout for the main window
    window.setLayout(mainLayout);

    // Set up a timer to call the state machine
    timer = new QTimer();
    QObject::connect(timer, &QTimer::timeout, []() {
        state_machine(); // Call the state machine function
    });
    timer->start(33);   //ms per UI frame

    // Show the window
    window.show(); // Show the application window (not full screen)

    // Execute the application
    int result = app.exec();

    // Clean up Marlin controller
    delete marlin;

    // Stop the camera when the application exits
    cam.stopVideo();

    return result;
}